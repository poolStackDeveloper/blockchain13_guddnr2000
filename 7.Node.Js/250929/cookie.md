# HTTP의 본질 => 상태 비저장(Stateless)

왜? 클라이언트 상태를 계속 가져가지 않을까?

1. A사용자가 요청을 보내고 응답을 받으면 TCP 연결 (3Way, 요청과 응답, 4way) 끊긴다.
2. B사용자가 같은 서버에 요청을 보냈어. 근데? 위의 1번 요청과 응답 즉, 아까 A가 요청했다드라는 사실을 알 수 없다.
=> 모든 요청과 응답은 독립적으로 처리! 서버는 매번 처음 보는 손님처럼 응대

자 이건 알겠어!

## 왜 이렇게 설계되었을까?

가장 큰 이유 -> 서버 과부하
서버가 모든 클라이언트의 상태를 기억하면? 메모리를 계속 점유하게 됨
사용자가 점점 늘어날 수록 서버는 무거워짐

## 요청과 응답이라는 사이클이 생겼다.

1. 3-way-handshake
2. 요청과 응답을 주고 받음
3. 4-way-handshake

즉, 매 요청은 이 사이클을 반복하면서 독립적으로 처리됩니다.
이것을 비연결성이러고 부릅니다.

## 문제가 생김

현실에서 웹을 사용할 때는 글만 읽고 쓰는게 아니라, **나**라는 존재가 계속 이어져야 함.

- 로그인 후 권한이 필요한 페이지(게시판 글 쓰기, 수정 등등) 여전히 로그인 상태
사용자의 상태를 유지할 무언가가 필요함

## 상태를 유지하는 방법!

이 때 등장하는 개념이 바로 클라이언트 식별!
=> 브라우저 특정 공간에 나라는 존재를 저장하고? 매 요청을 보낼 때! 권한이 필요할때는?
=> 그 값을 보내서 인증 시키는 구조

대표적으로!

1. 세션
2. 쿠키

## 쿠키란?

HTTP => 상태를 기억하지 않는 프로토콜

매번 요청과 응답

그러면? 매 요청마다 나를 알려야 함!

1990년대 초반, 웹은 지금처럼 풍부한 서비스가 아니었음
단순한 문서 조회 수준

사용자가 어떤 페이지에서 다른 페이지(권한이 필요한 페이지)로 이동할 때마다
모든 정보를 새로 입력해야 했음!

- 로그인 후? 다른 페이지 이동! 또 로그인!(인증을 매번)
194년 Netscape의 개발자 Lou Montulli가 제안한게 바로 => 쿠키 저장 방식

**쿠키는 클라이언트(여기서 봤을때는 브라우저) 측에 데이터 저장**
이후 요청마다 자동으로 서버에 전달되도록 함으로써, 서버가 사용자를 식별

## res.setHeader란?

응답 헤더에 원하는 값을 심는 메서드에요.
=> 요청을 보내눈 주체 => 지금은 브라우저가 이 응답 헤더를 읽습니다.
=> 즉, "브라우저야 추가 정보를 같이 알아둬"라는 뜻
그 중에서도 `Set-Cookie`는
=> 마! 브라우저! 이 쿠키 저장해!라고 요청하는 것

```js
res.setHeader("Set-Cookie","user_id=guddnr2000; Domain=localhost; Path=/;");
```

- user_id=guddnr2000 : 저장할 쿠키의 이름과 값 => 키-값으로 되어있음 => 키-값 쌍은 개발자가 자유롭게 정할 수 있다.
- Domain=localhost : 이 쿠키가 적용될 도메인을 지정 => 지금은 로컬환경이니 localhost
  => 만약 example.com 으로 지정되면, 그 도메인에 요청을 보낼 때만 쿠키가 전송됨
- Path=/ : 이 쿠키가 적용될 경로를 지정
  => `/`로 설정했으니, 이 서버의 모든경로 (`/boards`,`/users`등등)에 요청할 때 활용함.

## 미들웨어

Express에서 미들웨어는 말 그대로 중간에서 가로채서 일하는 함수

- 클라이언트 요청이 ㄷ르어오면, 가장 먼저 등록된 미들웨어부터 실행됩니다.
- 각 미들웨어는 요청을 가공, 검증하는 역할로 많이 빼둠.
- 그리고 마지막에는 컨트롤러(라우터)로 요청이 도달함.
=> 즉, 요청과 응답의 중간 처리 단계

## next()는 무엇이냐?

말 그대로, 미들웨어단에서 코드가 끝났으니, 다음 단계로 넘겨라

/boards 요청을 한다

1. 미들웨어 먼저 발동
2. 로직 처리 후 next();
3. 이 이후에 진짜 로직이 발동

next()를 호출하면, 

```js
app.get("/boards", (req,res) => {
    console.log(`req.cookies.userId=${req.cookies.userId}`);    
    if(!(req.cookies.userId === "guddnr2000")) res.status(404).json({state: "false", message: "해당 유저가 없습니다."});
    res.sendFile(__dirname + "/views/boards/list.html");
})
```


### 1단계: 쿠키 문자열 예시

```js
const str = "token=wnqudgus1234";
```

쿠키 문자열은 보통 `"키=값"` 형태입니다. 여러 개일 때는 세미콜론으로 이어집니다.

---

### 2단계: 세미콜론(`;`)으로 나누기

```js
str.split(";");
```

쿠키가 하나뿐이라면 그대로 배열에 담기고, 여러 개라면 각각 나뉩니다.

```js
["token=wnqudgus1234"];
```

---

### 3단계: 등호(`=`)로 키-값 분리

```js
.map((v) => v.split("="))
```

결과는 다음과 같이 2차원 배열이 됩니다.

```js
[["token", "wnqudgus1234"]];
```

---

### 4단계: reduce로 객체화

```js
.reduce((acc, [k, v]) => {
  acc[k] = v;
  return acc;
}, {});
```

- `acc`는 누적 객체
- `[k, v]`는 구조 분해 할당으로 키와 값 분리
- `acc[k] = v`로 누적

최종 결과는:

```js
{
  token: "wnqudgus1234";
}
```

next()를 호출하면, express는 요청을 다음 미들웨어 또는 라우터로 넘겨줍니다.
쿠키 파서는 권한 자체를 검증해주는 역할보다는, 쿠키가 문자열값으로 존재하면

그걸 파싱해주는거임

그리고? middleware => 권한이 필요한 각 라우트에
그걸 검증하면 되는거지!
## 오늘 수업은 뭐할까?

**JWT(Json Web Token)** 수업입니다.

> **"사용자의 권한을 언제 발급하고 언제 검증하는지"** 구현

근데 이제 **"프론트엔드와 백엔드가 분리된 환경"**을 곁들인

즉, **cookie를 통한 인증**도 함께 다룹니다.  
**백엔드에서 로그인 처리 → 프론트(혹은 Postman)에서 보호된 요청 전송** → **JWT 검증** 구조를 완성해 봅니다.

## 오늘 수업의 목차

1. JWT 발급 흐름 (시퀀스 다이어그램)
2. JWT 검증 흐름 (시퀀스 다이어그램)
3. 로그인 시 JWT 발급
4. API 요청 시 JWT 검증
5. 쿠키에 토큰 저장하고 요청하기
6. JWT의 시간 속성

## 오늘 수업의 핵심

---

### 1. **JWT는 "비교"가 아니라 "검증"이다**

> 토큰 안에 담긴 유저 정보(payload)를 **그대로 신뢰하지 않는다**.
> 그 정보가 **변조되지 않았다는 증거**가 있는가?
> → 서명(Signature)으로 그걸 검증함.

---

### 2. **JWT는 "무조건 안전"한 게 아니다**

- `header`와 `payload`는 base64url로 인코딩된 **평문 문자열**이다.
- 누구나 읽을 수 있다. (ID, 이름, 권한 등 유출 가능)
- 진짜 중요한 건 `signature`이다.

  - 이건 서버가 가진 **비밀 키(secret)** 없이는 만들 수 없음.
  - 이 값이 있어야만 무결성 보장 = 변조 아님을 증명.

---

### 3. **JWT는 "서버의 부담을 줄이는 구조"다**

- 매번 DB를 조회해서 로그인 유저 정보를 확인하지 않음.
- 클라이언트가 토큰만 잘 들고 있다면,
  → **서버는 그 토큰이 진짜인지 검증만 하면 됨**.
- 즉, **로그인 상태를 서버가 기억하지 않아도 되는 구조**.

---

### 4. **그래서 JWT는 만료시간이 짧다**

> JWT의 핵심은 “검증”이지 “기억”이 아니다.

- 만료시간(`exp`)은 선택사항이지만 실무에선 **꼭 사용함**.
- 이유는 다음과 같음:

  - 탈취 당해도 피해를 줄일 수 있음.
  - 유저 로그아웃을 강제로 처리할 수는 없지만, 만료는 자동.
  - **서버가 상태를 기억하지 않는 구조이기 때문에**,
    무제한 유효 토큰은 매우 위험함.

## 이번 수업은 뭐할까?

우리는 지난 시간에 직접 `net.createServer()`를 사용해서 **TCP 소켓 기반의 서버를 구현**해봤습니다.
브라우저 없이도 서버와 클라이언트가 데이터를 주고받을 수 있다는 사실은 신기했지만, 곧 의문이 생겼죠.

> “그럼 우리가 이렇게 직접 요청을 파싱하고, 상태를 구분하고, 응답을 만들어내야 하는 건가요?”

---

## 이번 수업의 핵심

- 우리는 **TCP 수준에서 서버를 구현했다**.
  하지만 요청 하나를 처리하기 위해 너무 많은 수작업이 필요했다.
- `socket.write()`, `socket.end()`로는 요청과 응답의 흐름을 직접 관리해야 하고,
  요청마다 `method`, `path`, `Content-Length`, `body`까지 수작업으로 파싱해야 했다.
- 이 과정은 복잡하고 실수가 많다.
  → 그래서 우리는 **규칙이 정해진 프로토콜(HTTP)** 위에서 작업하기 시작한다.
  => TCP 통신의 구조의 심화!

## 이번 수업의 목차

1. **우리가 만든 TCP 서버 구조 복습**

   - `net.createServer()`의 구조 다시 살펴보기

2. **TCP 통신에서의 요청 흐름 분석**

   - 클라이언트가 서버에 요청을 보내는 구조
   - 서버는 어떻게 데이터를 읽고, 응답을 보낼까?

3. **하나의 요청-응답이 끝나면 무슨 일이 일어날까?**

   - `socket.end()`가 호출되는 순간
   - `4-way-handshake`와 연결 종료 구조 이해

4. **HTTP는 이 TCP 위에서 어떤 역할을 하는가?**

   - TCP와 HTTP의 계층 구조 정리
   - 우리가 직접 파싱했던 `GET`, `POST`, `body`가
     HTTP에선 어떻게 자동으로 처리되는지

## 오늘 확실히 가져갈 거

### TCP가 신뢰성을 보장한다는 의미

지속적인 통로

3-WAY
4-WAY

확실하게, 하나의 요청 하나의 응답 그 사이에 socket

TCP를 활용하여 HTTP 규약을 지키면서 요청 응답 해봤다.

### HTTP는 그냥 규칙일 뿐임

1. 클라이언트가 요청을 보낸다. (GET, POST)
2. 서버는 반드시 하나의 응답을 돌려준다.
